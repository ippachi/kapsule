# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `irb` gem.
# Please instead update this file by running `bin/tapioca gem irb`.

module IRB::Color
  class << self
    def clear(colorable: T.unsafe(nil)); end
    def colorable?; end
    def colorize(text, seq, colorable: T.unsafe(nil)); end
    def colorize_code(code, complete: T.unsafe(nil), ignore_error: T.unsafe(nil), colorable: T.unsafe(nil)); end
    def inspect_colorable?(obj, seen: T.unsafe(nil)); end

    private

    def dispatch_seq(token, expr, str, in_symbol:); end
    def scan(code, allow_last_error:); end
    def without_circular_ref(obj, seen:, &block); end
  end
end

IRB::Color::ALL = T.let(T.unsafe(nil), Integer)
IRB::Color::BLUE = T.let(T.unsafe(nil), Integer)
IRB::Color::BOLD = T.let(T.unsafe(nil), Integer)
IRB::Color::CLEAR = T.let(T.unsafe(nil), Integer)
IRB::Color::CYAN = T.let(T.unsafe(nil), Integer)
IRB::Color::DIM = T.let(T.unsafe(nil), Integer)
IRB::Color::ERROR_TOKENS = T.let(T.unsafe(nil), Array)
IRB::Color::GREEN = T.let(T.unsafe(nil), Integer)
IRB::Color::MAGENTA = T.let(T.unsafe(nil), Integer)
IRB::Color::RED = T.let(T.unsafe(nil), Integer)
IRB::Color::REVERSE = T.let(T.unsafe(nil), Integer)

class IRB::Color::SymbolState
  def initialize; end

  def scan_token(token); end
end

IRB::Color::TOKEN_KEYWORDS = T.let(T.unsafe(nil), Hash)
IRB::Color::TOKEN_SEQ_EXPRS = T.let(T.unsafe(nil), Hash)
IRB::Color::UNDERLINE = T.let(T.unsafe(nil), Integer)
IRB::Color::YELLOW = T.let(T.unsafe(nil), Integer)

class IRB::ColorPrinter < ::PP
  def pp(obj); end
  def text(str, width = T.unsafe(nil)); end

  class << self
    def pp(obj, out = T.unsafe(nil), width = T.unsafe(nil)); end

    private

    def screen_width; end
  end
end

module IRB::Notifier
  private

  def def_notifier(prefix = T.unsafe(nil), output_method = T.unsafe(nil)); end

  class << self
    def def_notifier(prefix = T.unsafe(nil), output_method = T.unsafe(nil)); end
  end
end

class IRB::Notifier::AbstractNotifier
  def initialize(prefix, base_notifier); end

  def exec_if; end
  def notify?; end
  def pp(*objs); end
  def ppx(prefix, *objs); end
  def prefix; end
  def print(*opts); end
  def printf(format, *opts); end
  def printn(*opts); end
  def puts(*objs); end
end

class IRB::Notifier::CompositeNotifier < ::IRB::Notifier::AbstractNotifier
  def initialize(prefix, base_notifier); end

  def def_notifier(level, prefix = T.unsafe(nil)); end
  def level; end
  def level=(value); end
  def level_notifier; end
  def level_notifier=(value); end
  def notifiers; end
end

class IRB::Notifier::ErrUndefinedNotifier < ::StandardError
  def initialize(val); end
end

class IRB::Notifier::ErrUnrecognizedLevel < ::StandardError
  def initialize(val); end
end

class IRB::Notifier::LeveledNotifier < ::IRB::Notifier::AbstractNotifier
  include ::Comparable

  def initialize(base, level, prefix); end

  def <=>(other); end
  def level; end
  def notify?; end
end

class IRB::Notifier::NoMsgNotifier < ::IRB::Notifier::LeveledNotifier
  def initialize; end

  def notify?; end
end

class IRB::OutputMethod
  def parse_printf_format(format, opts); end
  def pp(*objs); end
  def ppx(prefix, *objs); end
  def print(*opts); end
  def printf(format, *opts); end
  def printn(*opts); end
  def puts(*objs); end
end

class IRB::OutputMethod::NotImplementedError < ::StandardError
  def initialize(val); end
end

class RubyLex
  def initialize; end

  def check_code_block(code, tokens = T.unsafe(nil)); end
  def check_corresponding_token_depth(lines, line_index); end
  def check_newline_depth_difference; end
  def check_state(code, tokens = T.unsafe(nil), context: T.unsafe(nil)); end
  def check_string_literal(tokens); end
  def check_termination_in_prev_line(code, context: T.unsafe(nil)); end
  def each_top_level_statement; end
  def find_prev_spaces(line_index); end
  def initialize_input; end
  def is_method_calling?(tokens, index); end
  def is_the_in_correspond_to_a_for(tokens, index); end
  def lex; end
  def process_continue(tokens = T.unsafe(nil)); end
  def process_literal_type(tokens = T.unsafe(nil)); end
  def process_nesting_level(tokens = T.unsafe(nil)); end
  def prompt; end
  def set_auto_indent(context); end
  def set_input(io, p = T.unsafe(nil), context: T.unsafe(nil), &block); end
  def set_prompt(p = T.unsafe(nil), &block); end
  def take_corresponding_syntax_to_kw_do(tokens, index); end

  private

  def heredoc_scope?; end
  def in_keyword_case_scope?; end

  class << self
    def compile_with_errors_suppressed(code, line_no: T.unsafe(nil)); end
    def ripper_lex_without_warning(code, context: T.unsafe(nil)); end
  end
end

RubyLex::ERROR_TOKENS = T.let(T.unsafe(nil), Array)

class RubyLex::TerminateLineInput < ::StandardError
  def initialize; end
end
